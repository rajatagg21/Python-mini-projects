Great—here’s the **enhanced version** with **cancellation support** built into the `DialogFragment`. The fragment itself manages the processing coroutine, exposes a cancel button, and lets the host know if the user aborted.

---

## 1. `res/layout/progress_dialog.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="24dp"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content">

    <ProgressBar
        android:id="@+id/progressBar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:indeterminate="true" />

    <TextView
        android:id="@+id/progressText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Processing 0/0"
        android:paddingTop="16dp"
        android:textAppearance="?android:attr/textAppearanceMedium" />

    <TextView
        android:id="@+id/statusText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text=""
        android:paddingTop="8dp"
        android:textAppearance="?android:attr/textAppearanceSmall" />
</LinearLayout>
```

---

## 2. `ProcessingDialogFragment.kt`

```kotlin
class ProcessingDialogFragment(
    private val notifications: List<Notification>,
    private val processItem: suspend (Notification) -> Unit,
    private val onCompleted: () -> Unit = {},
    private val onCancelled: () -> Unit = {}
) : DialogFragment() {

    private var progressText: TextView? = null
    private var statusText: TextView? = null

    // Own scope so we can cancel independently
    private val processingScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    private var dialogInstance: AlertDialog? = null

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val view = LayoutInflater.from(requireContext()).inflate(R.layout.progress_dialog, null)
        progressText = view.findViewById(R.id.progressText)
        statusText = view.findViewById(R.id.statusText)

        val builder = AlertDialog.Builder(requireContext())
            .setTitle("Processing")
            .setView(view)
            .setCancelable(false)
            .setNegativeButton("Cancel") { _, _ ->
                // User tapped cancel
                statusText?.text = "Cancelling..."
                processingScope.cancel("User cancelled")
            }

        dialogInstance = builder.create()
        return dialogInstance as AlertDialog
    }

    override fun onStart() {
        super.onStart()
        startProcessing()
    }

    private fun startProcessing() {
        val total = notifications.size
        processingScope.launch {
            try {
                for ((index, notif) in notifications.withIndex()) {
                    if (!isActive) break // cooperative cancellation

                    processItem(notif) // long-running work

                    withContext(Dispatchers.Main) {
                        updateProgress(index + 1, total)
                    }
                }

                withContext(Dispatchers.Main) {
                    if (processingScope.coroutineContext[Job]?.isCancelled == true) {
                        statusText?.text = "Cancelled"; 
                        onCancelled()
                    } else {
                        onCompleted()
                    }
                    dismissAllowingStateLoss()
                }
            } catch (e: CancellationException) {
                withContext(Dispatchers.Main) {
                    statusText?.text = "Cancelled"
                    onCancelled()
                    dismissAllowingStateLoss()
                }
            } catch (t: Throwable) {
                withContext(Dispatchers.Main) {
                    statusText?.text = "Failed: ${t.message}"
                    dismissAllowingStateLoss()
                }
            }
        }
    }

    private fun updateProgress(current: Int, total: Int) {
        progressText?.text = "Processing $current/$total"
    }

    override fun onDestroyView() {
        super.onDestroyView()
        processingScope.cancel()
        progressText = null
        statusText = null
    }
}
```

---

## 3. Usage Example in an Activity or Fragment

```kotlin
fun startNotificationProcessing(notifications: List<Notification>) {
    val dialog = ProcessingDialogFragment(
        notifications = notifications,
        processItem = { notif ->
            // Simulate or perform real work; make sure it cooperates with cancellation
            // Example placeholder:
            delay(200) // replace with your inference/process(notif)
        },
        onCompleted = {
            // Called when all items processed successfully
            Toast.makeText(this, "Processing complete", Toast.LENGTH_SHORT).show()
        },
        onCancelled = {
            // Called if user cancelled
            Toast.makeText(this, "Processing cancelled", Toast.LENGTH_SHORT).show()
        }
    )

    dialog.show(supportFragmentManager, "processing_dialog")
}
```

> **Important:** In your actual `processItem` implementation (model inference etc.), ensure it checks for cancellation cooperatively if you have loops inside. For example:

```kotlin
suspend fun process(notification: Notification) {
    // If you have internal loops:
    for (chunk in notification.chunks) {
        ensureActive() // throws if cancelled
        // do chunk work
    }
}
```

---

### Key Behaviors

* **Cancel button** cancels the coroutine scope, stops further processing, updates status, and invokes `onCancelled`.
* **Completion callback** fires only if all items finished without cancellation.
* **Lifecycle-safe**: scope is cancelled when fragment view is destroyed to avoid leaks.

---

Do you want a variant that exposes this via a shared `ViewModel`/`StateFlow` instead, or one that updates a persistent foreground notification in parallel?
